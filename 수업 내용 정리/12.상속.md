# 상속

* 클래스를 멤버 변수와 메소드를 물려 받는 것
* 상속을 하는 이유
  * 코드의 길이를 줄일 수 있다
  * 미리 만들어진 클래스를 상속 받아 활용할 수 있다
  * 다형성을 이용하여 객체를 관리하거나 메소드에 활용할 수 있다
    * 제공되는 메소드 중에서 매개변수로 특정 클래스를 상속 받아야 사용할 수 있는 메소드들이 있다
* 상속은 클래스를 선언(생성)할 때 사용 : extends 키워드를 활용
* 상속하는 방법

```java
//클래스A는 클래스B에게 상속을 받음
//부모 : 클래스B, 자식 : 클래스A
class 클래스A extends 클래스B {
    
}
```

* 상속을 받으면 부모 클래스에 있는 멤버 변수, 메소드를 물려받고, 접근제한자에 따라 접근권한이 결정
  * public, protected로 된 멤버 변수/메소드를 사용할 수 있다
  * default는 같은 패키지이면 사용 가능하나 다른 패키지이면 사용할 수 없다

* 필요에 따라 자식 클래스는 메소드를 추가할 수 있다
  * 메소드 오버로딩을 통해 부모 클래스의 메소드와 이름이 같은 메소드를 만들수 있다
  * 새로운 메소드를 만들 수 있다
* 클래스를 상속할 때 부모클래스는 1개만 가능 : 여러 부모가 있을 수 없다

```java
class B{
    void print(){
        System.out.println("B");
    }
}
class C{
    void print(){
        System.out.println("C");
    }
}
//에러 발생
//A가 B와C로부터 상속이 가능하다면 print()라는 부모 클래스의 메소드를 호출할 때 누구의 print()인지 알수 없기 때문에 안됨
class A extends B,C{
    void printTest(){
        print();
    }
}
```

* 인터페이스를 상속할 때 부모 인터페이스는 여러개 가능



### 메소드 오버라이딩

* 부모 클래스에게 물려받은 메소드를 재정의하는 것
* 부모 클래스의 메소드와 형태가 동일
  * 리턴타입이 같다
  * 메소드명이 같다
  * 매개변수의 타입과 갯수가 같다
  * 접근제한자는 좁은 범위로 만들 수 없다
* 메소드 위에 `@Override`를 추가해도 된다
  * `@Override`를 추가하는 이유는 해당 메소드가 오버라이딩 된 것을 표시

### super

* 부모 객체를 가르키는 키워드
* 메소드 오버라이딩을 할 때 부모 클래스에 있는 메소드를호출 사용

### super()

* 부모클래스의 생성자를 호출
* 자식 클래스의 생성자에서 사용
* 생성자 코드 첫줄 나와야 함
  * this()생성자와 super()생성자를 같이 쓸 때 super()생성자를 먼저 써야 한다.
* 자식 클래스의 생성자에 부모클래스의 생성자가 없으면 부모 클래스의 기본 생성자 super()가 자동으로 생성
* 부모 클래스에서 물려 받은 멤버 변수들이 부모 클래스의 생성자를 통해 초기화를 할 수 있으면 super()를 통해 해결

### 클래스 형변환

* 상속 관계인 두 클래스에서 형 변환(자식과 조상)
* 자식 클래스의 객체를 부모 클래스의 객체로 자동 클래스 형변환할 수 있다.

```java
//자동형변환 가능
부모클래스 객체명1 = new 자식클래스명();
//자동형변환 가능
자식클래스 객체명2 = new 자식클래스명();
부모클래스 객체명3 = 객체명2;
```

* 부모 클래스의 객체를 자식 클래스의 객체로 형변환할 때는 조건부로 명시적 형변환 할 수 있다.

```java
//안되는 경우1
자식클래스 객체명1 = (자식클래스)new 부모클래스();
//안되는 경우2
부모클래스 객체명2 = new 부모클래스();
자식클래스 객체명3 = (자식클래스)객체명2;
//되는 경우
부모클래스 객체명4 = new 자식클래스();
자식클래스 객체명5 = (자식클래스)객체명4;
```

### instanceof

* 클래스 형변환이 가능한 참/거짓으로 알려주는 연산자
* 일반적으로 if문과 같이 사용

```java
객체명 instanceof 클래스명;
```



### 다형성

* 객체 타입이 정해져 있지 않고, 여러 타입이 올 수 있게 되는 상황(자식 클래스들)
* 다형성이 필요한 곳(매개변수, 멤버 변수)에 부모 클래스의 객체로 선언

* 매개변수의 다형성
  * 매개변수로 다양한 객체들이 올 수 있는 상황

```java
//부모 클래스란 매개변수에 들어 갈 수 있는 객체들의 부모
접근제한자 리턴타입 메소드명(부모클래스 객체명){
    
}
```

* 멤버 변수의 다형성
  * 멤버변수로 다양한 객체들이 올 수 있는 상황

```java
class 클래스명{
    //부모클래스란 클래스명의 부모 클래스가 아니라 멤버 변수가 될 수 있는 객체들의 부모
    부모클래스명 멤버변수명;
}
```



### has a 관계, is a 관계

* is a 관계 : 상속관계
  * A는 B이다로 표현가능하면 상속
  * 스마트폰은 폰이다 : O
    * 폰 클래스를 상속받아 스마트폰 클래스로 만들 수 **있다**
  * 스마트폰은 카메라이다 : X
    * 카메라 클래스를 상속받아 스마트폰 클래스로 만들 수 **없다**
* has a 관계 : 포함관계
  * A는 B를 가지고 있다로 표현 가능하면 멤버 변수
  * 스마트폰은 폰을 가지고 있다 : X
  * 스마트폰은 카메라를 가지고 있다 : O
    * 카메라 클래스의 객체가 스마트폰의 멤버 변수가 된다

### final

* 수정할 수 없는
* 멤버 변수에 final이 붙으면 상수
  * 멤버변수가 상수이면, 명시적 초기화를 하거나 초기화 블록에서 초기화를 해야한다.(클래스/객체 멤버 공통)
  * 객체 멤버변수인 경우는 생성자에서도 할 수 있다.
* 메소드에 final이 붙으면 오버라이딩이 불가능
  * 상속 받은 자식 클래스에서 오버라이딩이 불가능
* 클래스에 final이 붙으면 상속이 불가능
  * 부모가 될수 없다
  * 대표적으로 String 클래스





